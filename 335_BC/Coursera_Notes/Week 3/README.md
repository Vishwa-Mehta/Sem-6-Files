# Week 3 - Algorithms and Techniques
### Algorithms and Techniques:
- 2 techniques - securing chain, efficient verification and validation:
	- Hashing
	- Asymmetric key encryption
## Public-key cryptography:
- Symmetric key enc:
	- SAME key used for enc and dec
	- Ex: Caesar Cipher, etc.
	- Issues:
		- easy to derive secret key from encrypted data
		- key distribution?
- How public key crypto takes care of these:
	- 2 different keys - private and public
	- public key - published
	- private key - kept safe 
	- enc function properties:
		- data enc with priv key  can be dec with pub key and vice versa
	- auth sender and reciever:
		- E = enc<sub>privk(a)</sub>(enc<sub>pubk(b)</sub>(M))
		- M = dec<sub>privk(b)</sub>(dec<sub>pubk(a)</sub>(E))
		- ONLY b could have recieved it and only a could have sent it
	- ex: RSA(Rivest Shamir Adleman) Algo but blockchain needs more efficient algo
	- So Elliptic Curve Cryptography(ECC) family of algos is used in bitcoin and ethereum blockchain for generating key pair/encryption
	- Why??
		- For a given no of bits ECC is stronger than RSA -> 256 bit ECC ~ 3072 bit RSA
## Secure Hashing:
- for integrity of ttxn and confidentiality of data
- transofrms/maps an arbitrary len of input data value to a fixed length value
- input data can be - document, tree data or block data
- even a slight diff in data produces a totally diff hash
- requirements of a hash function:
	- algo should be "ONE WAY function"
	- "COLLISION FREE" or low probablity of collision
- no one can derive the original value of the hash
- hash uniquely represents the original item
- made sure by using a strong algo such as secure hash and by using large no of bits in the hash value
- most common hash size now -> 256 bits
- comon functions -> SHA-3, SHA-256, Keccak-256
- 2 approaches for hashing based on how the constituent elements are organised
	- simple hash
		-  all data - linearly arranged and hashed
	- merkle tree hash
		- data at leaf nodes
		- leaves - pair wise hashed to get same hash value as a simple hash
- If  we take "addition" as the hash function then for data 10,4,6,21,19 we have hash = 60
- Simple Hash used when 
	- fixed no of items to be hashed
	- verify composite block integrity not individual item integrity
- Tree hash used when
	- no of items differ from block to block (txns, states, receipts)
		- state is a variable that may be modified by smart contract execution and result of execution returned in a receipt
	- helps for repeated operations
-  in thereum hashing functions are used to generate
	- acc addresses
	- digital signatures
	- txn hash
	- state hash
	- receipt hash
	- block header hash
## Transaction Integrity:
- to manage integrity of txn we need
	- secure + unique acc address
	- std approach to uniquely identify participants in the network
	- auth of txn by sender through digital sign
	- verification that the content of the txn isn't modified
- addresses of accounts - generated by public/pvt key pair 
	- step 1: 256 bit random no is generated = pvt key - locked using a passphrase
	- step 2: ecc algo applied to pvt key = public key
	- step 3: hash applied to public key = acc address (160 bits)
- txn inititated by the address
	- authorise txn
	- non-repudiable
	- unmodifiable
- sign the txn digitally
- data --> hashed + enc = digital signature
- reciever gets original data + digitally signed hash
- can compute hash of the data recievd and verify the hash given - verifies integrity
- for txn as the data
	- step 1: find hash of data fields of txns
	- step 2: enc<sub>privk(participant)</sub>(hash) + DS(txn) (authorise + make txn non repudiable)
	- step 3: add hash to the txn (verified by others dec using the public key of sender and recomputing hash of txn hash same -> accept txn :) or else reject)
	- for complete verification --> time stamp, nonce, acc balances, sufficiency of fees also verified
## Securing Blockchain/Block Integrity:
- components of the ethereum block:
	- header
	- txns with the txn hash / txn root
	- state hash / state root
- integrity of block?
	- make sure HEADER contents and txns are not tampered
	- state transitions - computed efficiently, hashed and verified
- in ethereum - block hash:
	- all the elements in block header incl txn root and state root hashes
	- using Keccak
![Pasted image 20230208193547.png](./9.png)
![9](https://user-images.githubusercontent.com/83157662/217571985-e2f3c44f-ba09-40e2-a723-f9bcb0dd91c8.png)
- typical block - 2000 txns - bitcoin and 100 txns - ethereum
- merkle tree hash
	- used for computing state root hash as only hash of "changed" states have to be computed
	- also used for receipt hash root as ONLY ONE path to tree should be checked not having to go through all txns
	- every state change requires root hash re-computation not all states
	- only affected path in the merkle tree re-computed
![Pasted image 20230208194109.png](./10.png)
![10](https://user-images.githubusercontent.com/83157662/217572009-22b857a3-8b1f-49e0-b16a-1ed1ec56e149.png)

- block hash computation:
	- state root hash + txn root hash + receipt root hash + all other header items + variable nonce --keccak-256--> proof of work solved
	- purpose of block hash 
		- integrity of block and txns
		- formation of chainlink - embeds prev block hash in current block header
	- hence immutability of the chain :)