# Week 1 - Blockchain defined
## BitCoin and Blockchain:
- Enable peer-to-peer transfer of digital assets without **intermediaries** in a **decentralised** network.
- Originally created to support BitCoin
- Trust between unknown peers
- Recording txn in an immutable ledger
- Establishing trust through:
	- Validation
	- Verification
	- Consensus
	- Immutable recording
### Intro of bitcoin:
- contributions:
	- digital currency system
	- autonomous decentralised application
- Satoshi Nakamoto: new currency - BitCoin
- p2p transfer of value without any central authority
- Security and trust?
	- software programs for validation, verification, consensus in an infrastucture called **blockchain**.

## Blockchain Structure:
### Basic Structure of a blockchian:
- Transaction: basic element of bitcoin blockchain
- they're validated and broadcast
- many transactions -> form a block
- many blocks -> chain through a digital data link
- blocks need to be **verified** so they go through a **consensus** process to select next block that's to be added to the chian
- this **validation and consensus** are carried out by special peer nodes called "**miners**".
- miners: **powerful** computers executing the **software** that's defined by the "blockchain protocol".
### Single Transaction:
- Fundamental concept -> **Unspent Transaction Output** -> **UTXO**
- all UTXOs collectively **define the state** of the bitcoin blockchain
- referenced as "**inputs**" in a transaction, they're also "**outputs**" of a txn.
- stored by the participant nodes in the blockchain
- txn uses the "amount" specified in UTXOs and "transmits" it to newly created **output** UTXOs.
- UTXO contains:
	- **Unique identifier** of transaction that **created** the UTXO
	- **index/position** of the UTXO in the **txn output** list
	- **value/amount**
	- **conditions under which it can be spent** -> optional
- Txn contains:
	- **reference number** of "current txn"
	- refernce to >= 1 input **input UTXOs**
	- refernce to >= 1 input **output UTXOs** generated by the txn
	- total **input and output** amoutn
- Transaction Number
![Pasted image 20230110222749](./2.png)
![2](https://user-images.githubusercontent.com/83157662/211811430-3b59b1f2-7825-4b65-87e5-d33ad87b5a0e.png)
- amount in 3 input UTXOs is used to generate 2 new output UTXOs
- the numbers are the references to the UTXOs
![Pasted image 20230110222458](./1.png)
![1](https://user-images.githubusercontent.com/83157662/211811334-0b401937-bc65-4fb4-b0b7-2490f78998bb.png)
- total amount vlaue transferred in bitcoins
![Pasted image 20230110223039](./3.png)
![3](https://user-images.githubusercontent.com/83157662/211811483-67472c5c-49f0-41f2-a04a-0b6aba265d6d.png)
- header and info
- set of valid txns
- genesis block -> introduced for future blocks -> block number zero
- this was created by Satoshi Nakamoto - one txn of 50 BTC 
![Pasted image 20230110223251](./4.png)
![4](https://user-images.githubusercontent.com/83157662/211811511-cb4a2f3e-1097-4da5-8ca1-71ce061ea406.png)
- hash of prev block in in the next block
![Pasted image 20230110223806](./5.png)
![5](https://user-images.githubusercontent.com/83157662/211811567-7cd56621-408b-4aac-b81f-55649b085ddb.png)
- txns -> transfer of value in the bitcoin blockchain
- UTXO -> defines inputs and outputs of a txn
- once block verified -> agreed by miners algorithmically -> added to chain of blocks -> **blockhain**
## Basic Operations:
- Resposibility of peers and their computational nodes (ie their systems - laptops, desktops, server racks, etc.)
- Operations include:
	1. **Validation** of txns
	2. **Gathering** txns for a block
	3. **Broadcasting** these valid txns in a block
	4. **Consensus** on next block creation
	5. **Chaining blocks** to form an immutable record
- Participant roles:
	- those who **initiate transfer of value** ie create txn
	- **Miners** who also 
		- verify txn -> carried out independently by all miners
		- broadcast txns
		- compete to **claim right to the block**
		- work on **reaching consensus** by vlaidating block
		- **broadcast newly created block**
		- confirm txns
- miners get paid in BitCoin for these efforts
- process of validation includes many criteria (>20) like size, syntax, etc.
	- Referenced input adn output UTXOs are valid and correct
	- Input and output amounts are matched
- set of txns are selcted from the pool of valid txns to create a block
- If EVERY miner adds a block to the chain then we have a problem as it leads to multiple branches of the chain creating an inconsistency :/. How to overcome this?
- Miners compete by **solving a "computational" and CPU intensive puzzle** to determine who owns the right to the block
- that solved block is **broadcast** -> participants reach consensus -> block added to chain and confirmed
- block is also added to every local copy of the blockchain
![Pasted image 20230111194830](./6.png)
![6](https://user-images.githubusercontent.com/83157662/211892064-b072c8dc-4807-4dc5-a333-711c69abe867.png)
- algorithm for consensus : **Proof of Work** protocol
- Index 0 of Transaction 0 is created by the miner of the block -> has a special UTXO and no **input** UTXO -> **Coinbase transaction** that generates -> **Miners fee** (currently 12.5BTC) -> new coint minted in bitcoin
## Beyond Bitcoin:
- Bitcoin source code is open source and source code was extended to release diff cryptocurrencies
- 300+ cruptocurrencies were introduced
- BitCoin has a special feature -> **Scripts** -> for **conditional transfer** of values
- **Ethereum** -> extended the feature to an execution framework -> **Smart Contracts**
- Smart contracts provide -> ability of **code execution** -> embeds **business logic** on the blockchain
- Based on this we have 3 types of blockchain:
	1. Only coins in cryptocurrency. Ex: BitCoin
	2. Cryptocurrency + Business logic layer. Ex: Ethereum
	3.  Only Business Logic, No currency. Ex: Linux Foundation Hyperledger
- Blockchain Categories (Based on Access Limits):
	- Public
		- Ex: BitCoin
		- Wallet applications -> interface to transfer value through the chain
	- Private
		- Access to blockchain limited to selected participants
		- Helps simplify operations : block creation and contingence model
		- controlled access to blockchain
	- Permissioned/Consortium
		- meant for a grp of collaborating parties to transact on a blockchain to ease governance, provenance and accountability
		- Ex: consortium of automobile companies
		- Benefits of Public blockchain and allowing only users with permissions to transact and operate
		- controlled access to blockchain
# Week 2 - Ethereum Blockchain 
## Smart Contracts:
- framework for execution of code was introduced by ethereum founders
- enables transactions that carry out more sophisticated operations
- like a class definition in an object oriented design
- has data, functions, access specifiers, getter and setters
- many languages to write smart contracats - ex Solidity
![Pasted image 20230126191138.pn](./7.png)
![7](https://user-images.githubusercontent.com/83157662/217571846-ce5262c2-731c-49c5-a730-b6db04a930f9.png)
- Parts of the code:
	- **pragma**: specifies version of solidity used
	- **contract**:  specifies the start of the contract
	- **uint**: data type unsigned int
	- **function**: for write and read of data 
- Exceution of code? -> computational infra? -> every node should be able to execute the code irrespective of the the underlying stuff like OS, H/W, etc. 
- Ethereum Virtual Machine (EVM): run anywhere abstraction
- High level prog lang -> EVM Byte Code -> deployed on the EVM
- smart contracts allow execution of code -> enhancing basic value transfer capability of blockchain

## Ethereum Structure:
- Ethereum introduced "accounts" in the txn -> originator and the target of a txn
- directly updates the acc balances instead of maintaining a "state" like in UTXOs
- transmit of values n messages n data that may result in state transitions -> implemented using txns
- accs are basic units of the ethereum protocol
- 2 types of accounts:
	- externally owned (EOA)
		- controlled by pvt keys
		- needed to participate in the network
		- interacts w/ chain using txns
	- contract (CA)
		- can be activated only by an EOA
		- represents a smart contract
		- every acc has coin balance
		- participant can send txn to send ether or invoke a smart contract
		- payed in **Wei**, 1 Ether = 10<sup>18</sup> Wei 
- txn ethereum has:
	- recepient of message
	- DS of the sender for authorisation
	- amt of wei to tranfer
	- optional payload with message to a contract
	- startgas - value repres the max no of computational steps for the txn
	- gasprice - sender fee for the computation
- ethereum block structure has:
	- header
	- txns
	- runner-up blk headers 
## Ethereum Operations:
- for a transfer - amt + trget addr + fees/gas points
- the fees are transfered to the accs
![Pasted image 20230126211114.png](./8.png)
![8](https://user-images.githubusercontent.com/83157662/217571917-34b76c0c-8065-4c79-b7e1-7564858c4827.png)
- eth node - computational sys representing the bussiness entity or the individual participant
- eth full node - hosts s/w for txn init, validation, etc...
- smart contract - designed, developed compiled, deployed on the EVM 
- more than one SC in and EVM
- execution code corresponding to the SC is activated and executed on the EVM - input extracted from the payload of the txn
- curr state of SC - values of the vars defined in it - state updated by this exec - result of exec stored in a receipt - blockchain maintains the state hash and the receipt hash
- all txns generated are validated
	- TS and Nonce combination is valid
	- sufficient fees are available for exec
- invoked SC code is executed by all miners
- validated txns are braodcast and gathered for block creation
- consensus protocol used - Memory based not CPU based PoW
## Incentive Model:
- gas related items in a txn:
	- every action requires crypto fuel/gas
	- gas points are used to specify the for ease of computation
	- gas points allow - independent valuation of txn fee and computation fee
	- ether varies as market prices change, gas points don't
- gas related items in a block:
	- gas limit - amt of gas points available 
	- gas spent - actual amt of gas spent at the completion of each block
- mining incentive model:
	- miner incentivised with the base fees of 3 eths + txn fee in blockchain + fees for execution of contract txns
	- miners who solve the puzzle but don't win - ommers - blocks created are called "ommer blocks" added as "side blocks" to the main chain
	- ommer miners also get a small % of total gas points as consolation and for n/w sec
- any transaction requires fees (transfer of ether included) to be specified in the txn
# Week 3 - Algorithms and Techniques
### Algorithms and Techniques:
- 2 techniques - securing chain, efficient verification and validation:
	- Hashing
	- Asymmetric key encryption
## Public-key cryptography:
- Symmetric key enc:
	- SAME key used for enc and dec
	- Ex: Caesar Cipher, etc.
	- Issues:
		- easy to derive secret key from encrypted data
		- key distribution?
- How public key crypto takes care of these:
	- 2 different keys - private and public
	- public key - published
	- private key - kept safe 
	- enc function properties:
		- data enc with priv key  can be dec with pub key and vice versa
	- auth sender and reciever:
		- E = enc<sub>privk(a)</sub>(enc<sub>pubk(b)</sub>(M))
		- M = dec<sub>privk(b)</sub>(dec<sub>pubk(a)</sub>(E))
		- ONLY b could have recieved it and only a could have sent it
	- ex: RSA(Rivest Shamir Adleman) Algo but blockchain needs more efficient algo
	- So Elliptic Curve Cryptography(ECC) family of algos is used in bitcoin and ethereum blockchain for generating key pair/encryption
	- Why??
		- For a given no of bits ECC is stronger than RSA -> 256 bit ECC ~ 3072 bit RSA
## Secure Hashing:
- for integrity of ttxn and confidentiality of data
- transofrms/maps an arbitrary len of input data value to a fixed length value
- input data can be - document, tree data or block data
- even a slight diff in data produces a totally diff hash
- requirements of a hash function:
	- algo should be "ONE WAY function"
	- "COLLISION FREE" or low probablity of collision
- no one can derive the original value of the hash
- hash uniquely represents the original item
- made sure by using a strong algo such as secure hash and by using large no of bits in the hash value
- most common hash size now -> 256 bits
- comon functions -> SHA-3, SHA-256, Keccak-256
- 2 approaches for hashing based on how the constituent elements are organised
	- simple hash
		-  all data - linearly arranged and hashed
	- merkle tree hash
		- data at leaf nodes
		- leaves - pair wise hashed to get same hash value as a simple hash
- If  we take "addition" as the hash function then for data 10,4,6,21,19 we have hash = 60
- Simple Hash used when 
	- fixed no of items to be hashed
	- verify composite block integrity not individual item integrity
- Tree hash used when
	- no of items differ from block to block (txns, states, receipts)
		- state is a variable that may be modified by smart contract execution and result of execution returned in a receipt
	- helps for repeated operations
-  in thereum hashing functions are used to generate
	- acc addresses
	- digital signatures
	- txn hash
	- state hash
	- receipt hash
	- block header hash
## Transaction Integrity:
- to manage integrity of txn we need
	- secure + unique acc address
	- std approach to uniquely identify participants in the network
	- auth of txn by sender through digital sign
	- verification that the content of the txn isn't modified
- addresses of accounts - generated by public/pvt key pair 
	- step 1: 256 bit random no is generated = pvt key - locked using a passphrase
	- step 2: ecc algo applied to pvt key = public key
	- step 3: hash applied to public key = acc address (160 bits)
- txn inititated by the address
	- authorise txn
	- non-repudiable
	- unmodifiable
- sign the txn digitally
- data --> hashed + enc = digital signature
- reciever gets original data + digitally signed hash
- can compute hash of the data recievd and verify the hash given - verifies integrity
- for txn as the data
	- step 1: find hash of data fields of txns
	- step 2: enc<sub>privk(participant)</sub>(hash) + DS(txn) (authorise + make txn non repudiable)
	- step 3: add hash to the txn (verified by others dec using the public key of sender and recomputing hash of txn hash same -> accept txn :) or else reject)
	- for complete verification --> time stamp, nonce, acc balances, sufficiency of fees also verified
## Securing Blockchain/Block Integrity:
- components of the ethereum block:
	- header
	- txns with the txn hash / txn root
	- state hash / state root
- integrity of block?
	- make sure HEADER contents and txns are not tampered
	- state transitions - computed efficiently, hashed and verified
- in ethereum - block hash:
	- all the elements in block header incl txn root and state root hashes
	- using Keccak
![Pasted image 20230208193547.png](./9.png)
![9](https://user-images.githubusercontent.com/83157662/217571985-e2f3c44f-ba09-40e2-a723-f9bcb0dd91c8.png)
- typical block - 2000 txns - bitcoin and 100 txns - ethereum
- merkle tree hash
	- used for computing state root hash as only hash of "changed" states have to be computed
	- also used for receipt hash root as ONLY ONE path to tree should be checked not having to go through all txns
	- every state change requires root hash re-computation not all states
	- only affected path in the merkle tree re-computed
![Pasted image 20230208194109.png](./10.png)
![10](https://user-images.githubusercontent.com/83157662/217572009-22b857a3-8b1f-49e0-b16a-1ed1ec56e149.png)

- block hash computation:
	- state root hash + txn root hash + receipt root hash + all other header items + variable nonce --keccak-256--> proof of work solved
	- purpose of block hash 
		- integrity of block and txns
		- formation of chainlink - embeds prev block hash in current block header
	- hence immutability of the chain :)
